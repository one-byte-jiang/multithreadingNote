====并发基础=====

（单核情况下做出乱序优化并没啥影响，多核并发情况下就会出现问题）

1.CPU多级缓存-乱序执行优化

例如：a=10----->b=200----->result=2000

在CPU乱序执行优化的时候可能会变成以下执行顺序：

例如：b=200----->a=10----->result=2000

计算过程虽然不会对结果造成影响，如何是多核同时运行就会出现与预期结果不同的概率


2.JAVA内存模型（简称:JMM）

变量存放在栈  对象是存放在堆

3.并发的优势与风险
优势
①.提高的程序的效率，同时处理多个请求，响应更快。
②.资源利用，CPU等待IO可以做其他的事情
风险
①多个线程争夺共享数据时，会产生与期望不符的结果
②某个操作无法继续进行下去，就会出现死锁、饥饿等问题   （注:考虑安全性,会对线程加锁，如果对加锁解锁操作不当，就会引发死锁的情况）
③线程过多使用，CPU负荷增大，内存也会随之消耗



====线程安全性=====
1.保证线程安全的手段

原子性:提供了互斥访问,同一时刻只能有一个线程来对它进行操作

可见性:一个线程对主内存的修改可以及时的被其他线程观察到

有序性:一个线程观察其他线程中的指令执行顺序，由于指令 重排序的存在，该观察结果一般杂乱无序

原子性--Atomic包  CAS 就是（compareAndSwap首字母的缩写命名）
注意（面试可能会问）:AtomicInteger使用了unsafe类

AtomicInteger实现原理：调用compareAndSwapInt方法 当前的值与从底层主内存取出来的值是预期相同的就进行相加计算，如果与预期的值不同，将会在死循环中阻塞等待

AtomicLong与LongAdder的区别：
上面说到的AtomicInteger的原理，如果与预期不符合就会死循环一直判断，如果其他线程对共享变量修改失败的情况下，AtomicInteger还是会死循环的比较，性能会受到影响
LongAdder是在AtomicLong的基础上，将单点的更新压力分散到各个节点上（在低并发情况下，通过单点更新和Atomic性能基本一致，在高并发的情况下，通过分散提高性能）

LongAdder的缺点：
在统计并发更新的时候，统计的数据会有些误差，在高并发计数情况下，优先使用LongAdder，低并发情况下使用AtomicLong还是比较简单方便，比如生成序列号全局唯一的数值，使用AtomicLong比较好

AtomicIntegerFieldUpdater的作用是，原子性的更新某一个类中某一个字段的值，而字段是必须用volatile修饰，同时不能是static字段